---
title: "Brief Analysis of Ship Placement Probabilities & Strategies in Game 'BattleShip'"
author: "Aceri"
date: "Mar 22, 2020"
output: html_document

---

## Synopsis


A brief vignette analysis of placement density of ships in the traditional game Battleship


## Configuration


I will be using knitr to publish the document on the web as a markdown document.

I use some libraries listed below. The data is autogenerated and does not need any connection, external source or access to disk.



```{r setup, include=TRUE, fig.width=15,fig.height=11}
knitr::opts_chunk$set(echo = TRUE)


#install.packages("viridis")
#install.packages("formattable")
require(viridis)
require("lattice")
library(formattable)
library(sqldf)



verify_OpenWaters<-function(i_row,i_col,ship_Size,matrix,ver1_hor0)
{
  DEBUG=0
  Open_Area=1
  if(ver1_hor0==0) for (i in 0:(ship_Size-1)) if (matrix[i_row,i_col+i]>0) Open_Area=0
  if(ver1_hor0==1) for (j in 0:(ship_Size-1)) if (matrix[i_row+j,i_col]>0) Open_Area=0
  if (Open_Area==0 & DEBUG==1) print("The area is not free !!")
  return(Open_Area)
}

place_Ship<-function(ship_Size,matrix,mark_type=1)
{
  # mark_type is the type of marks we will apply to the battlefield matrix when the ship is placed:
  #      1 - just ones
  #      2 - ship_Size - 22, 333, 333, 4444, 55555
  #      3 - orientation - horizontal / vertical
  
  DEBUG=0
  not<-function(x) return(ifelse(x==1,0,1))
  test_matrix<-matrix
  Open_Area=1
  
  hh=ifelse(sample(0:1,1)==0,0,1)
  i_row=sample(1:(dim(test_matrix)-not(hh)*ship_Size)[1],1)
  i_col=sample(1:(dim(test_matrix)-hh*ship_Size)[2],1)
  if (DEBUG==1) print(paste("Trying to add ",ifelse(hh==1,"horizontal","vertical")," ship of size ",ship_Size," at position ",i_row,",",i_col,sep=""))    
  while(verify_OpenWaters(i_row,i_col,ship_Size,test_matrix,not(hh))==0)
  {
    i_row=sample(1:(dim(test_matrix)-not(hh)*ship_Size)[1],1)
    i_col=sample(1:(dim(test_matrix)-hh*ship_Size)[2],1)
    if (DEBUG==1) print(paste("Trying to add ",ifelse(hh==1,"horizontal","vertical")," ship of size ",ship_Size," at position ",i_row,",",i_col,sep=""))    
  }
  for(i in 0:(ship_Size-1))
  {
    if(test_matrix[i_row+not(hh)*i,i_col+hh*i]==0)
    {
      test_matrix[i_row+not(hh)*i,i_col+hh*i]=ifelse(mark_type==1,1,ifelse(mark_type==2,ship_Size,1+ver1_hor0))
      if (DEBUG==1) print(paste("    Coordinates ",i_row,",",i_col+i,"=",test_matrix[i_row+not(hh)*i,i_col+hh*i],sep=""))
    } else {
      print("ERROR: Why here?")
    }
  }
  return(test_matrix)
}

place_fleet<-function(matrix,mark_type=1)
{
  matrix<-place_Ship(2,matrix,mark_type)
  matrix<-place_Ship(3,matrix,mark_type)
  matrix<-place_Ship(4,matrix,mark_type)
  matrix<-place_Ship(5,matrix,mark_type)
  matrix<-place_Ship(6,matrix,mark_type)
  return(matrix)
}
```


I generate a fleet random placement with 5 ships of 2,3,3,4 and 5 tiles long each. Ships can be placed either vertically or horizontally. They don't overlap.

After an sequence of 1000 equal fleet random placement iteration is created and a sum is added based on the frequency of tiles occupied.


```{r populating, include=TRUE, fig.width=15,fig.height=11}
empty_matrix<-matrix(0,nrow=10,ncol=10)
sumat_matrix<-matrix(0,nrow=10,ncol=10)
colnames(sumat_matrix)<-toupper(letters[c(1:10)])
rownames(sumat_matrix)<-c(1:10)

for(a in 1:1000)
{
  sumat_matrix<-sumat_matrix+place_fleet(empty_matrix)  
}


formattable(sumat_matrix)
```

## DEFENSE 

Let's display a heatmap of ship tiles occupied after 10,000 random placements.

It would seem better to place the ships in the borders of the board.


```{r heatmap, include=TRUE, fig.width=15,fig.height=11}

levelplot(sumat_matrix,col.regions=inferno(500),xlab.top="BATTLESHIP GAME - RANDOM SHIP 10000 PLACEMENT MONTECARLO HEATMAP")

```

## ATTACK 

# Could we quantify the outcome of some firing stretegies based on the lowest of turns needed to sink all the ships using the average of X game runs?


The game rules we will use as a basis of the study are:

1- The Standard fleet is placed randomly. It has 5 ships:

  + Ship of length 2
  + Ship of length 3
  + Ship of length 3
  + Ship of length 4
  + Ship of length 5
  
2- We know and can remember where we have already shot
3- We know when we have hit an objective in a specifc tile
4- When we manage to sink a ship, we know it.


Example placement:


```{r attack, include=TRUE, fig.width=15,fig.height=11}
matrix<- place_fleet(empty_matrix)  
formattable(matrix)

```

# Strategy

1- Measure random firing with no memory not caring for past fires or results, just blind random firing x y until all sunk
2- Measure random firing not repeating shoots
3- Measure random firing not repeating shoots and killing off found ships

4- TBD: Algo1 : Create a checker board approach where the distance between the tiles being tested (bombed) is -> Min(Size(RemainingEnemyShips()))
5- TBD: Algo2 : Algo1 giving a shooting preference to checkered tiles ordered by the heat map frequency of randomly positioning 1000 the ships.




```{r attack_strategy1, include=TRUE, fig.width=15,fig.height=11}

check_Square <- function(x,y,matrix,verbose=0)
{
  ret=ifelse(matrix[x,y]>0,matrix[x,y],0)
  if (verbose == 2) print(paste("check_Square > ret for ",x," , ",y," = ",ret,sep=""))
  return(ret)
}

fire_Square <- function(x,y,matrix,verbose=0)
{
  ret=0
  ret=check_Square(x,y,matrix)
  if (ret>0) 
  {
    matrix[x,y]=0
    if (verbose==2) print(paste("fire_Square > Ship hit at ",x,",",y," = ",ret,sep=""))
  } else { 
    if (verbose==2) print(paste("fire_Square > Water at ",x,",",y," = ",ret,sep=""))
  }
  return(matrix)
}

shots_byStrategy<-function(number_runs=100,strategy=1,verbose=0)
{
  result_df <- data.frame(strategy=character(),num_shots=integer(),run_number=integer(),stringsAsFactors=FALSE) 
  for (a in 1:number_runs)
  {
    if (verbose == 1) print(paste("RUN NUMBER : ",a,sep=""))
    matrix<- place_fleet(empty_matrix,mark_type=2)  
    result_df[a,1]=strategy
    result_df[a,2]=sink_All(matrix,strategy,verbose)
    result_df[a,3]=a
  }
  return(result_df)
}




is_SinkingShip <-function(ship_Size,strategy_matrix, verbose=0) 
{
  if (sum(sum(strategy_matrix==ship_Size)) < ship_Size & sum(sum(strategy_matrix==ship_Size)) > 0) 
    ret = ship_Size - sum(sum(strategy_matrix==ship_Size)) else ret = 0
  if (verbose > 1 & ret > ship_Size) print(paste("        is_SinkingShip > Ship Squares missing of type ",ship_Size," ? : ",ret,sep=""))
  return (ret)
}

sinking_Ships <- function(strategy_matrix,verbose = 0)
{
  ret = FALSE
  for (a in 2:6)
  {
    if (is_SinkingShip(a,strategy_matrix) > 0) ret = TRUE
  }
  if (verbose > 0) print(paste("    sinking_Ships > Any ? : ",ret,sep=""))
  return (ret)    
}


last_position_SinkingShips<-function(strategy_matrix,verbose=0)
{
  
  sinking_Df <- data.frame(row=integer(),col=integer(),ship_size=integer(),stringsAsFactors=FALSE) 
  killoff_Df <- data.frame(row=integer(),col=integer(),stringsAsFactors=FALSE) 
  for (k in 2:6)
  {
    if (is_SinkingShip(k,strategy_matrix) > 0 )
    {
      if (verbose > 1) print(paste("last_position_SinkingShips > Ship ",k," is sinking - remaining tiles = ",k-sum(sum(strategy_matrix==k))))
      if (verbose > 1) which(strategy_matrix==k,arr.ind=TRUE)
      pre_sinking_Df<-as.data.frame(which(strategy_matrix==k,arr.ind=TRUE))
      pre_sinking_Df$ship_size<-k
      sinking_Df<-rbind(sinking_Df,pre_sinking_Df)
    }
  }
  return(sinking_Df)
}



kill_off_SinkingShips<-function(sinking_Df,matrix,previous_shot_matrix,selection_type=0,verbose=0,debug=0)
{
  if (debug==1)
  {
    print("/////////////////////////////////////////////////")
    print("kill_off_SinkingShips > WARNING: DEBUGGING ACTIVE")
    print("/////////////////////////////////////////////////")
    number_runs=1
    strategy=3
    verbose=2
    previous_shot_matrix<-previous_shot_matrix3
    sinking_Df <- last_position_SinkingShips(previous_shot_matrix,verbose)
    selection_type=0
  }

  max_row=dim(previous_shot_matrix)[1]
  max_col=dim(previous_shot_matrix)[2]
  if (selection_type==0)
  {
    ship_with_min_remaining_tiles <- sqldf("select ship_size,count(*) as num_tiles,row,col from sinking_Df group by ship_size order by num_tiles ")[1,1]
    previous_hits <- as.data.frame(which(previous_shot_matrix==ship_with_min_remaining_tiles,arr.ind=TRUE))
    possible_shots_X=c(max(1,min(copy_previous_hits[1,])-1),min(max_row,max(copy_previous_hits[1,])+1))
    possible_shots_Y=c(max(1,min(copy_previous_hits[2,])-1),min(max_col,max(copy_previous_hits[2,])+1))
    #Creating combination from possible shots

    distinct_row=sqldf("select distinct(1) from previous_hits") 
    distinct_col=sqldf("select distinct(2) from previous_hits")
    direction=ifelse(distinct_row==distinct_col,0,ifelse(distinct_row>distinct_col,-1,1))
    if (verbose == 2 & direction ==  1) print(paste("kill_off_SinkingShips > The ship is placed vertically"))
    if (verbose == 2 & direction == -1) print(paste("kill_off_SinkingShips > The ship is placed horizontally"))

    shoot_list <- data.frame(X=integer(),Y=integer(),stringsAsFactors=FALSE)    
    for (z in 1:2)
    {
      for (w in 1:nrow(previous_hits))
      {
        if (z == 1)
        {
          for (j in 1:length(possible_shots_Y))
          {
            if (check_Square(previous_hits[w,1] ,possible_shots_Y[j], previous_shot_matrix) ==0 & direction != -1)
            {
                print("HERE ")
                if(verbose==2) print(paste("kill_off_SinkingShips > ",ifelse(direction==0,"SHIP DIRECTION UNKNOWN",ifelse(direction==1,"SHIP DIRECTION HORIZONTAL","SHIP DIRECTION VERTICAL"))," : new_shoot : ",previous_hits[w,1]," , ",possible_shots_Y[j],sep=""))
                new_shoot <- c(previous_hits[w,1],possible_shots_Y[j])
                shoot_list <- rbind(shoot_list,new_shoot)    
            }
          }
        } else {
          for (i in 1:length(possible_shots_X))
          {
            if (check_Square(possible_shots_X[i],previous_hits[w,2] , previous_shot_matrix) ==0 & direction != 1)
            {
                if(verbose==2) print(paste("kill_off_SinkingShips > ",ifelse(direction==0,"SHIP DIRECTION UNKNOWN",ifelse(direction==1,"SHIP DIRECTION HORIZONTAL","SHIP DIRECTION VERTICAL"))," : new_shoot : ",possible_shots_X[i]," , ", previous_hits[w,2],sep=""))
                new_shoot <- c(possible_shots_X[i],previous_hits[w,2])
                shoot_list <- rbind(shoot_list,new_shoot)    
            }
          }
        }
      }
    }
    names(shoot_list) <- c("row","col")
    if (verbose == 2) print(paste("kill_off_SinkingShips > Number of possible non tested shoots around sinking ship previous hit : ",nrow(shoot_list),sep=""))
    choose_row <- sample(1:nrow(shoot_list),1)
    x = shoot_list[choose_row,1]
    y = shoot_list[choose_row,2]
    if (verbose == 2) print(paste("kill_off_SinkingShips > Trying the following coordinate randomly salacted from availabe shoots around previous hit : ",x," , ",y,sep=""))
    if (verbose == 2) print(paste("kill_off_SinkingShips > Preparing shot at coordinates ",x,",",y," !!!",sep=""))
    previous_shot_matrix[x,y] = 1     
    matrix_pre_fire <- matrix
    matrix <- fire_Square(x,y,matrix,verbose)
    if (sum(matrix_pre_fire) != sum(matrix))
    {
      if (verbose == 2) print("kill_off_SinkingShips > SHIP HIT - Storing the type of ship in previous_shot_matrix")
      previous_shot_matrix[x,y] <- matrix_pre_fire[x,y]
      if (verbose>1 & sum(sum(previous_shot_matrix==2))==ship_with_min_remaining_tiles) print(paste("kill_off_SinkingShips > SHIP TYPE ",ship_with_min_remaining_tiles," SUNK !!",sep=""))
    } 
    if (verbose == 2) print(paste("kill_off_SinkingShips > Number of Remaining Ship Cells : ", sum(sum(matrix>0))," , Number of missing shots : ",sum(sum(previous_shot_matrix==1)) ," , Number of Hits : ",sum(sum(previous_shot_matrix>1)) ,sep=""))
  }
  if (debug==1) previous_shot_matrix3 <- previous_shot_matrix
  return(previous_shot_matrix)
}

# sinking_Ships <- function(matrix)
# {
#   sinking = 0
#   if (sum())
#   return(sinking)
# }

sink_All <- function(matrix,strategy = 1,verbose = 0, debug=0)
{
  if (debug==1)
  {
    print("////////////////////////////////////")
    print("sink_All > WARNING: DEBUGGING ACTIVE")
    print("////////////////////////////////////")
    number_runs=1
    strategy=3
    verbose=2
    matrix<- place_fleet(empty_matrix,mark_type=2)  
  }
  shot_Counter = 0

  if (verbose==2) print("sink_All > Initializing previous shot matrix")
  if (verbose == 2) print(paste("sink_All > Using Strategy ",strategy,sep=""))
  if (strategy == 2) previous_shot_matrix2 <- matrix(0,nrow=dim(matrix)[1],ncol=dim(matrix)[2])
  if (strategy == 3) previous_shot_matrix3 <- matrix(0,nrow=dim(matrix)[1],ncol=dim(matrix)[2])

  while(sum(matrix) > 0)
  {
    if (verbose ==2) print(paste("sink_All > sum(matrix) = ",sum(matrix),sep=""))
    if (verbose == 2) print(paste("sink_All > shot number ",shot_Counter,sep=""))
    if (strategy == 1) matrix <- fire_Square(sample(1:dim(matrix)[1],1),sample(1:dim(matrix)[2],1),matrix,verbose)
    if (strategy == 2)
    {
      x <- sample(1:dim(matrix)[1],1)
      y <- sample(1:dim(matrix)[1],1)
      while(check_Square(x,y,previous_shot_matrix2) > 0)
      {
        x <- sample(1:dim(matrix)[1],1)
        y <- sample(1:dim(matrix)[1],1)
      }
      previous_shot_matrix2[x,y] = 1
      matrix <- fire_Square(x,y,matrix,verbose)
    }
    if (strategy == 3 )
    {
      if (verbose==2 & sinking_Ships(matrix)) print("sink_All > We have sinking ships")
      if (!sinking_Ships(matrix))
      {
        x <- sample(1:dim(matrix)[1],1)
        y <- sample(1:dim(matrix)[1],1)
        if (verbose == 2) print(paste("sink_All > Verifying if we already shot at coordinates ",x,",",y," = ",check_Square(x,y,previous_shot_matrix3),sep=""))
        while(check_Square(x,y,previous_shot_matrix3) > 0)
        {
          x <- sample(1:dim(matrix)[1],1)
          y <- sample(1:dim(matrix)[1],1)
          if (verbose == 2) print(paste("sink_All > We had already shot there !. Verifying if we already shot at coordinates ",x,",",y," = ",check_Square(x,y,previous_shot_matrix3),sep=""))
        }
        check = check_Square(x,y,previous_shot_matrix3) 
        if (check > 0) 
        { 
          if (verbose > 0) print("sink_All > This should not be happening")
          previous_shot_matrix3[x,y] = check
        } else { 
          if (verbose == 2) print(paste("sink_All > I have never shot at coordinates ",x,",",y,". Storing coordinates for future and firing",sep=""))
          previous_shot_matrix3[x,y] = 1 
        }
        if (verbose == 2) print(paste("sink_All > Preparing shot at coordinates ",x,",",y," !!!",sep=""))
        matrix_pre_fire <- matrix
        matrix <- fire_Square(x,y,matrix,verbose)
        if (sum(matrix_pre_fire) != sum(matrix))
        {
          if (verbose == 2) print("sink_All > SHIP HIT - Storing the type of ship in previous_shot_matrix")
          previous_shot_matrix3[x,y] <- matrix_pre_fire[x,y]
        } 
        if (verbose == 2) print(paste("sink_All > Number of Remaining Ship Cells : ", sum(sum(matrix>0))," , Number of missing shots : ",sum(sum(previous_shot_matrix3==1)) ," , Number of Hits : ",sum(sum(previous_shot_matrix3>1)) ,sep=""))
      } else {
        print("sink_All > We have sinking ships already, killing them off first as per Strategy 3 !")
        sinking_Df<-last_position_SinkingShips(previous_shot_matrix3,verbose)
        previous_shot_matrix3<-kill_off_SinkingShips(sinking_Df,matrix,previous_shot_matrix=previous_shot_matrix3,selection_type=0,verbose)
      }
        
    }
    shot_Counter=shot_Counter + 1
  }
  if (verbose > 0 & strategy == 1) print(paste("Strategy ",strategy," - All Sunk - it took : ",shot_Counter," shots",sep = ""))
  if (verbose > 0 & strategy == 2) print(paste("Strategy ",strategy," - All Sunk - it took : ",shot_Counter," shots - remembered: ",sum(previous_shot_matrix2),sep = ""))
  if (verbose > 0 & strategy == 3) print(paste("Strategy ",strategy," - All Sunk - it took : ",shot_Counter," shots - remembered: ",sum(previous_shot_matrix3),sep = ""))
  return(shot_Counter)
}

#  TESTING PURPOSES - STRATEGY 3
#  matrix<- place_fleet(empty_matrix,mark_type=2)  
#  rm(previous_shot_matrix3)
#  previous_shot_matrix3<-matrix(0,nrow=dim(matrix)[1],ncol=dim(matrix)[2])
#  strat3_df <- as.data.frame(shots_byStrategy(runs,strategy=3,verbose=2))


runs = 1
verbose = 2
strat1_df <- shots_byStrategy(runs,strategy = 1,verbose)
strat2_df <- shots_byStrategy(runs,strategy = 2,verbose)
strat3_df <- shots_byStrategy(runs,strategy = 3,verbose)
title1_str=paste("HISTOGRAM - Shots Needed to Sink All Ships ",runs," Runs",sep="")
title2_str=paste("SCATTERPLOT - Shots Needed to Sink All Ships ",runs," Runs",sep="")
par(mfrow=c(3,2))
hist(strat1_df$num_shots,main=paste("STRATEGY 1 'Random Shooting, No Memory' : ",title1_str,sep=""),xlab="Number of Shots",freq=TRUE,breaks=20,col="orange")
plot(strat1_df$num_shots,main=title2_str,xlab="Run Number",ylab="Shots Needed",col="black",ylim=c(0,max(strat1_df$num_shots)))
  lines(lowess(strat1_df$run_number,strat1_df$num_shots),col="orange")

hist(strat2_df$num_shots,main=paste("STRATEGY 2 'Random Shooting, No Repeated Shots' : ",title1_str,sep=""),xlab="Number of Shots",freq=TRUE,breaks=20,col="orange")
plot(strat2_df$num_shots,main=title2_str,xlab="Run Number",ylab="Shots Needed",col="black",ylim=c(0,max(strat2_df$num_shots)))
  lines(lowess(strat1_df$run_number,strat2_df$num_shots),col="orange")

hist(strat3_df$num_shots,main=paste("STRATEGY 3 'Random Shooting, Killing off found Ships' : ",title1_str,sep=""),xlab="Number of Shots",freq=TRUE,breaks=20,col="orange")
plot(strat3_df$num_shots,main=title2_str,xlab="Run Number",ylab="Shots Needed",col="black",ylim=c(0,max(strat3_df$num_shots)))
  lines(lowess(strat1_df$run_number,strat3_df$num_shots),col="orange")



```

```{r dif_strategy2and3, include=TRUE, fig.width=15,fig.height=11}

mean(strat2_df$num_shots)
mean(strat3_df$num_shots)


```

## Conclusion

Not finished yet.


